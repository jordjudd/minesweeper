@using Minesweeper.Models
@model GameBoard

<h1>Minesweeper</h1>

<div class="game-info">
    <div class="difficulty-selector">
        <label for="difficultySelect">Difficulty:</label>
        <select id="difficultySelect" onchange="changeDifficulty()">
            <option value="Easy" selected="@(Model.CurrentDifficulty == Difficulty.Easy)">Easy (9x9, 10 mines)</option>
        </select>
    </div>
    <div class="status" id="gameStatus">
        @if (Model.Status == GameStatus.Playing)
        {
            <span>Playing - Mines: @Model.MineCount</span>
        }
        else if (Model.Status == GameStatus.Won)
        {
            <span class="won">You Won! üéâ</span>
        }
        else if (Model.Status == GameStatus.Lost)
        {
            <span class="lost">Game Over üí•</span>
        }
    </div>
</div>

<div class="controls">
    <button onclick="newGameWithCurrentDifficulty()">New Game</button>
    <button onclick="debugBoard()" style="background-color: #ff9800;">Debug Board</button>
    <button onclick="showAllMines()" style="background-color: #e91e63; color: white;">Show All Mines</button>
</div>

<div class="game-board" id="gameBoard">
    @for (int i = 0; i < Model.Rows; i++)
    {
        <div class="row">
            @for (int j = 0; j < Model.Cols; j++)
            {
                var cell = Model.Board[i][j];
                var cellClass = "cell";
                var cellContent = "";
                
                if (cell.IsRevealed)
                {
                    cellClass += " revealed";
                    if (cell.IsMine)
                    {
                        cellClass += " mine";
                        cellContent = "üí£";
                    }
                    else if (cell.AdjacentMines > 0)
                    {
                        cellContent = cell.AdjacentMines.ToString();
                    }
                }
                else if (cell.IsFlagged)
                {
                    cellClass += " flagged";
                    cellContent = "üö©";
                }
                
                <div class="@cellClass" data-row="@i" data-col="@j" onclick="revealCell(@i, @j)" oncontextmenu="toggleFlag(@i, @j); return false;">
                    @cellContent
                </div>
            }
        </div>
    }
</div>

@section Scripts {
    <script>
        function revealCell(row, col) {
            // Don't allow clicks on revealed or flagged cells
            var cell = $('[data-row="' + row + '"][data-col="' + col + '"]');
            if (cell.hasClass('revealed') || cell.hasClass('flagged')) {
                return;
            }

            $.post('/Home/RevealCell', { row: row, col: col }, function(data) {
                if (data.success) {
                    console.log('Cell revealed:', data);
                    
                    // Update all revealed cells
                    if (data.revealedCells) {
                        console.log('Updating ' + data.revealedCells.length + ' cells');
                        
                        // Check for mines in the revealed cells (should be 0)
                        var minesInRevealedCells = data.revealedCells.filter(function(cell) {
                            return cell.isMine;
                        });
                        
                        if (minesInRevealedCells.length > 0) {
                            console.error('CRITICAL ERROR: Server sent mines in revealed cells!', minesInRevealedCells);
                        } else {
                            console.log('‚úÖ Server correctly sent 0 mines in revealed cells');
                        }
                        
                        data.revealedCells.forEach(function(cellData) {
                            updateCellSafely(cellData.row, cellData.col, cellData);
                        });
                    }
                    
                    updateGameStatus(data.gameStatus);
                    
                    // If game is over, disable all clicks
                    if (data.gameStatus === 'Won' || data.gameStatus === 'Lost') {
                        $('.cell').css('pointer-events', 'none');
                    }
                } else {
                    console.error('Error:', data.error);
                    alert('Error: ' + data.error);
                }
            }).fail(function(xhr, status, error) {
                console.error('AJAX Error:', error);
                alert('Network error: ' + error);
            });
        }

        function toggleFlag(row, col) {
            console.log('toggleFlag called for cell:', row, col);
            
            $.post('/Home/ToggleFlag', { row: row, col: col }, function(data) {
                if (data.success) {
                    console.log('Flag toggled successfully:', data);
                    updateCellFlag(row, col, data.isFlagged);
                    updateGameStatus(data.gameStatus);
                } else {
                    console.error('Error:', data.error);
                    alert('Error: ' + data.error);
                }
            }).fail(function(xhr, status, error) {
                console.error('AJAX Error:', error);
                alert('Network error: ' + error);
            });
        }

        function newGame() {
            $.post('/Home/NewGame', function(data) {
                if (data.success) {
                    // Re-enable clicks and reload page for fresh game
                    $('.cell').css('pointer-events', 'auto');
                    location.reload();
                } else {
                    console.error('Error:', data.error);
                    alert('Error: ' + data.error);
                }
            }).fail(function(xhr, status, error) {
                console.error('AJAX Error:', error);
                alert('Network error: ' + error);
            });
        }

        function updateCellSafely(row, col, data) {
            var cell = $('[data-row="' + row + '"][data-col="' + col + '"]');
            
            // CRITICAL: Never display mines during cascade (server should never send them)
            if (data.isMine) {
                console.error('üö® CRITICAL: Server sent a mine during cascade at (' + row + ',' + col + ')', data);
                return; // Don't update mine cells during cascade
            }
            
            if (data.isRevealed) {
                // Clear any previous styling first
                cell.removeClass('mine mine-debug flagged');
                cell.css({
                    'background-color': '',
                    'border': ''
                });
                
                // Add revealed styling
                cell.addClass('revealed');
                
                // Show numbers for safe cells (including 0)
                cell.text(data.adjacentMines);
                
                console.log('‚úÖ Updated safe cell (' + row + ',' + col + ') with ' + data.adjacentMines + ' adjacent mines');
            }
        }

        // Keep the old function for compatibility
        function updateCell(row, col, data) {
            updateCellSafely(row, col, data);
        }

        function updateCellFlag(row, col, isFlagged) {
            var cell = $('[data-row="' + row + '"][data-col="' + col + '"]');
            
            if (isFlagged) {
                cell.addClass('flagged');
                cell.removeClass('revealed'); // Make sure it's not marked as revealed
                cell.text('üö©');
            } else {
                cell.removeClass('flagged');
                cell.text('');
            }
        }

        function updateGameStatus(status, mineCount) {
            var statusElement = $('#gameStatus');
            mineCount = mineCount || @Model.MineCount;
            
            if (status === 'Won') {
                statusElement.html('<span class="won">You Won! üéâ</span>');
                showGameOver('üéâ Congratulations! You Won! üéâ', 'won');
            } else if (status === 'Lost') {
                statusElement.html('<span class="lost">Game Over üí•</span>');
                showGameOver('üí• Game Over! You hit a mine! üí•', 'lost');
            } else {
                statusElement.html('<span>Playing - Mines: ' + mineCount + '</span>');
            }
        }

        function showGameOver(message, type) {
            $('#gameOverText').html(message);
            $('#gameOverMessage').removeClass('won lost').addClass(type);
            $('#gameOverOverlay').show();
            
            // Make the message draggable
            makeDraggable($('#gameOverMessage')[0]);
        }

        function hideGameOver() {
            $('#gameOverOverlay').hide();
        }

        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            
            element.onmousedown = dragMouseDown;
            
            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }
            
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
            }
            
            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        function startNewGame() {
            hideGameOver();
            newGameWithCurrentDifficulty();
        }

        function changeDifficulty() {
            // Only Easy mode for now
            location.reload();
        }

        function newGameWithCurrentDifficulty() {
            // Clear all debug styling before starting new game
            $('.cell').removeClass('mine-debug').css({
                'background-color': '',
                'border': ''
            });
            
            $.post('/Home/NewGame', function(data) {
                if (data.success) {
                    // Just reload the page for a completely fresh start
                    location.reload();
                } else {
                    console.error('Error:', data.error);
                    alert('Error: ' + data.error);
                }
            }).fail(function(xhr, status, error) {
                console.error('AJAX Error:', error);
                alert('Network error: ' + error);
            });
        }

        function debugBoard() {
            $.get('/Home/GetBoardState', function(data) {
                if (data.success) {
                    console.log('=== FULL BOARD DEBUG INFO ===');
                    console.log('Board State:', data);
                    console.log('Detailed Mine Info:', data.detailedMineInfo);
                    console.log('Board Statistics:', data.boardStatistics);
                    
                    // Log each mine's status
                    console.log('=== MINE STATUS DETAILS ===');
                    data.detailedMineInfo.forEach(function(mine) {
                        console.log(`Mine at (${mine.row},${mine.col}): ${mine.status} - Revealed: ${mine.isRevealed}, Flagged: ${mine.isFlagged}`);
                    });
                    
                    // Verify mine counting for a few cells
                    var verificationResults = [];
                    data.board.forEach(function(cell) {
                        if (!cell.isMine && cell.adjacentMines > 0) {
                            var actualCount = 0;
                            for (var i = -1; i <= 1; i++) {
                                for (var j = -1; j <= 1; j++) {
                                    var checkRow = cell.row + i;
                                    var checkCol = cell.col + j;
                                    var adjacentCell = data.board.find(c => c.row === checkRow && c.col === checkCol);
                                    if (adjacentCell && adjacentCell.isMine) {
                                        actualCount++;
                                    }
                                }
                            }
                            if (actualCount !== cell.adjacentMines) {
                                verificationResults.push({
                                    position: '(' + cell.row + ',' + cell.col + ')',
                                    expected: cell.adjacentMines,
                                    actual: actualCount
                                });
                            }
                        }
                    });
                    
                    console.log('Mine Count Verification:', verificationResults);
                    
                    // Build detailed message
                    var stats = data.boardStatistics;
                    var message = '=== MINESWEEPER DEBUG REPORT ===\n\n';
                    message += 'Game Info:\n';
                    message += `- Difficulty: ${data.difficulty}\n`;
                    message += `- Size: ${data.rows}x${data.cols}\n`;
                    message += `- Game Status: ${data.gameStatus}\n\n`;
                    
                    message += 'Board Statistics:\n';
                    message += `- Total Cells: ${stats.totalCells}\n`;
                    message += `- Total Mines: ${stats.totalMines}\n`;
                    message += `- Total Safe Cells: ${stats.totalSafeCells}\n`;
                    message += `- Revealed Cells: ${stats.revealedCells}\n`;
                    message += `- Revealed Mines: ${stats.revealedMines}\n`;
                    message += `- Revealed Safe Cells: ${stats.revealedSafeCells}\n`;
                    message += `- Hidden Cells: ${stats.hiddenCells}\n`;
                    message += `- Flagged Cells: ${stats.flaggedCells}\n`;
                    message += `- Correct Flags: ${stats.correctFlags}\n`;
                    message += `- Incorrect Flags: ${stats.incorrectFlags}\n\n`;
                    
                    message += 'Mine Details:\n';
                    data.detailedMineInfo.forEach(function(mine) {
                        message += `- Mine at (${mine.row},${mine.col}): ${mine.status}\n`;
                    });
                    
                    if (stats.revealedMines > 0 && data.gameStatus === 'Playing') {
                        message += '\nüö® CRITICAL ISSUE: Mines revealed during gameplay!\n';
                    }
                    
                    if (verificationResults.length > 0) {
                        message += '\n‚ùå Client-side mine count errors found! Check console for details.\n';
                    } else {
                        message += '\n‚úÖ Client-side mine counting verification: PASSED\n';
                    }
                    
                    if (data.validationErrors && data.validationErrors.length > 0) {
                        message += '\n‚ùå Server-side validation errors:\n';
                        data.validationErrors.forEach(function(error) {
                            message += `- ${error}\n`;
                        });
                        console.log('Server validation errors:', data.validationErrors);
                    } else {
                        message += '\n‚úÖ Server-side validation: PASSED\n';
                    }
                    
                    alert(message);
                } else {
                    console.error('Error:', data.error);
                    alert('Error: ' + data.error);
                }
            }).fail(function(xhr, status, error) {
                console.error('AJAX Error:', error);
                alert('Network error: ' + error);
            });
        }

        function showAllMines() {
            $.get('/Home/GetBoardState', function(data) {
                if (data.success) {
                    console.log('Revealing all mines for debugging');
                    
                    // Clear any existing debug styling first
                    $('.cell').removeClass('mine-debug').css({
                        'background-color': '',
                        'border': ''
                    });
                    
                    // Show all mines on the board
                    data.minePositions.forEach(function(mine) {
                        var cell = $('[data-row="' + mine.row + '"][data-col="' + mine.col + '"]');
                        cell.addClass('mine-debug');
                        cell.text('üí£');
                        cell.css({
                            'background-color': '#ffcccc',
                            'border': '2px solid #ff0000'
                        });
                    });
                    
                    alert('All ' + data.minePositions.length + ' mines are now visible with pink background and red border.\nClick "New Game" to reset.');
                } else {
                    console.error('Error:', data.error);
                    alert('Error: ' + data.error);
                }
            }).fail(function(xhr, status, error) {
                console.error('AJAX Error:', error);
                alert('Network error: ' + error);
            });
        }


    </script>
}