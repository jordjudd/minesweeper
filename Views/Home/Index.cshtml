@using Minesweeper.Models
@model GameBoard

<h1>Minesweeper</h1>

<div class="game-info">
    <div class="difficulty-selector">
        <label for="difficultySelect">Difficulty:</label>
        <select id="difficultySelect" onchange="changeDifficulty()">
            <option value="Easy" selected="@(Model.CurrentDifficulty == Difficulty.Easy)">Easy (9x9, 10 mines)</option>
        </select>
    </div>
    <div class="status" id="gameStatus">
        @if (Model.Status == GameStatus.Playing)
        {
            <span>Playing - Mines: @Model.MineCount</span>
        }
        else if (Model.Status == GameStatus.Won)
        {
            <span class="won">You Won! ðŸŽ‰</span>
        }
        else if (Model.Status == GameStatus.Lost)
        {
            <span class="lost">Game Over ðŸ’¥</span>
        }
    </div>
</div>

<div class="controls">
    <button onclick="newGameWithCurrentDifficulty()">New Game</button>
    <button onclick="debugBoard()" style="background-color: #ff9800;">Debug Board</button>
    <button onclick="showAllMines()" style="background-color: #e91e63; color: white;">Show All Mines</button>
</div>

<div class="game-board" id="gameBoard">
    @for (int i = 0; i < Model.Rows; i++)
    {
        <div class="row">
            @for (int j = 0; j < Model.Cols; j++)
            {
                var cell = Model.Board[i, j];
                var cellClass = "cell";
                var cellContent = "";
                
                if (cell.IsRevealed)
                {
                    cellClass += " revealed";
                    if (cell.IsMine)
                    {
                        cellClass += " mine";
                        cellContent = "ðŸ’£";
                    }
                    else if (cell.AdjacentMines > 0)
                    {
                        cellContent = cell.AdjacentMines.ToString();
                    }
                }
                else if (cell.IsFlagged)
                {
                    cellClass += " flagged";
                    cellContent = "ðŸš©";
                }
                
                <div class="@cellClass" data-row="@i" data-col="@j" onclick="revealCell(@i, @j)" oncontextmenu="toggleFlag(@i, @j); return false;">
                    @cellContent
                </div>
            }
        </div>
    }
</div>

@section Scripts {
    <script>
        function revealCell(row, col) {
            // Don't allow clicks on revealed or flagged cells
            var cell = $('[data-row="' + row + '"][data-col="' + col + '"]');
            if (cell.hasClass('revealed') || cell.hasClass('flagged')) {
                return;
            }

            $.post('/Home/RevealCell', { row: row, col: col }, function(data) {
                if (data.success) {
                    console.log('Cell revealed:', data);
                    
                    // Update all revealed cells
                    if (data.revealedCells) {
                        data.revealedCells.forEach(function(cellData) {
                            updateCell(cellData.row, cellData.col, cellData);
                        });
                    }
                    
                    updateGameStatus(data.gameStatus);
                    
                    // If game is over, disable all clicks
                    if (data.gameStatus === 'Won' || data.gameStatus === 'Lost') {
                        $('.cell').css('pointer-events', 'none');
                    }
                } else {
                    console.error('Error:', data.error);
                    alert('Error: ' + data.error);
                }
            }).fail(function(xhr, status, error) {
                console.error('AJAX Error:', error);
                alert('Network error: ' + error);
            });
        }

        function toggleFlag(row, col) {
            console.log('toggleFlag called for cell:', row, col);
            
            $.post('/Home/ToggleFlag', { row: row, col: col }, function(data) {
                if (data.success) {
                    console.log('Flag toggled successfully:', data);
                    updateCellFlag(row, col, data.isFlagged);
                    updateGameStatus(data.gameStatus);
                } else {
                    console.error('Error:', data.error);
                    alert('Error: ' + data.error);
                }
            }).fail(function(xhr, status, error) {
                console.error('AJAX Error:', error);
                alert('Network error: ' + error);
            });
        }

        function newGame() {
            $.post('/Home/NewGame', function(data) {
                if (data.success) {
                    // Re-enable clicks and reload page for fresh game
                    $('.cell').css('pointer-events', 'auto');
                    location.reload();
                } else {
                    console.error('Error:', data.error);
                    alert('Error: ' + data.error);
                }
            }).fail(function(xhr, status, error) {
                console.error('AJAX Error:', error);
                alert('Network error: ' + error);
            });
        }

        function updateCell(row, col, data) {
            var cell = $('[data-row="' + row + '"][data-col="' + col + '"]');
            
            if (data.isRevealed) {
                cell.addClass('revealed');
                cell.removeClass('flagged');
                
                if (data.isMine) {
                    cell.addClass('mine');
                    cell.text('ðŸ’£');
                } else if (data.adjacentMines > 0) {
                    cell.text(data.adjacentMines);
                } else {
                    cell.text('');
                }
            }
        }

        function updateCellFlag(row, col, isFlagged) {
            var cell = $('[data-row="' + row + '"][data-col="' + col + '"]');
            
            if (isFlagged) {
                cell.addClass('flagged');
                cell.removeClass('revealed'); // Make sure it's not marked as revealed
                cell.text('ðŸš©');
            } else {
                cell.removeClass('flagged');
                cell.text('');
            }
        }

        function updateGameStatus(status, mineCount) {
            var statusElement = $('#gameStatus');
            mineCount = mineCount || @Model.MineCount;
            
            if (status === 'Won') {
                statusElement.html('<span class="won">You Won! ðŸŽ‰</span>');
                showGameOver('ðŸŽ‰ Congratulations! You Won! ðŸŽ‰', 'won');
            } else if (status === 'Lost') {
                statusElement.html('<span class="lost">Game Over ðŸ’¥</span>');
                showGameOver('ðŸ’¥ Game Over! You hit a mine! ðŸ’¥', 'lost');
            } else {
                statusElement.html('<span>Playing - Mines: ' + mineCount + '</span>');
            }
        }

        function showGameOver(message, type) {
            $('#gameOverText').html(message);
            $('#gameOverMessage').removeClass('won lost').addClass(type);
            $('#gameOverOverlay').show();
            
            // Make the message draggable
            makeDraggable($('#gameOverMessage')[0]);
        }

        function hideGameOver() {
            $('#gameOverOverlay').hide();
        }

        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            
            element.onmousedown = dragMouseDown;
            
            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }
            
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
            }
            
            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        function startNewGame() {
            hideGameOver();
            newGameWithCurrentDifficulty();
        }

        function changeDifficulty() {
            // Only Easy mode for now
            location.reload();
        }

        function newGameWithCurrentDifficulty() {
            $.post('/Home/NewGame', function(data) {
                if (data.success) {
                    // Re-enable clicks and reload page for fresh game
                    $('.cell').css('pointer-events', 'auto');
                    location.reload();
                } else {
                    console.error('Error:', data.error);
                    alert('Error: ' + data.error);
                }
            }).fail(function(xhr, status, error) {
                console.error('AJAX Error:', error);
                alert('Network error: ' + error);
            });
        }

        function debugBoard() {
            $.get('/Home/GetBoardState', function(data) {
                if (data.success) {
                    console.log('Board State:', data);
                    console.log('Mine Positions:', data.minePositions);
                    
                    // Verify mine counting for a few cells
                    var verificationResults = [];
                    data.board.forEach(function(cell) {
                        if (!cell.isMine && cell.adjacentMines > 0) {
                            var actualCount = 0;
                            for (var i = -1; i <= 1; i++) {
                                for (var j = -1; j <= 1; j++) {
                                    var checkRow = cell.row + i;
                                    var checkCol = cell.col + j;
                                    var adjacentCell = data.board.find(c => c.row === checkRow && c.col === checkCol);
                                    if (adjacentCell && adjacentCell.isMine) {
                                        actualCount++;
                                    }
                                }
                            }
                            if (actualCount !== cell.adjacentMines) {
                                verificationResults.push({
                                    position: '(' + cell.row + ',' + cell.col + ')',
                                    expected: cell.adjacentMines,
                                    actual: actualCount
                                });
                            }
                        }
                    });
                    
                    console.log('Mine Count Verification:', verificationResults);
                    
                    var message = 'Difficulty: ' + data.difficulty + 
                                 ', Size: ' + data.rows + 'x' + data.cols + 
                                 ', Mines: ' + data.totalMines + '/' + data.expectedMines + 
                                 ', Initialized: ' + data.isInitialized;
                    
                    if (verificationResults.length > 0) {
                        message += '\n\nClient-side mine count errors found! Check console for details.';
                    } else {
                        message += '\n\nClient-side mine counting verification: PASSED';
                    }
                    
                    if (data.validationErrors && data.validationErrors.length > 0) {
                        message += '\n\nServer-side validation errors:';
                        data.validationErrors.forEach(function(error) {
                            message += '\n- ' + error;
                        });
                        console.log('Server validation errors:', data.validationErrors);
                    } else {
                        message += '\n\nServer-side validation: PASSED';
                    }
                    
                    alert(message);
                } else {
                    console.error('Error:', data.error);
                    alert('Error: ' + data.error);
                }
            }).fail(function(xhr, status, error) {
                console.error('AJAX Error:', error);
                alert('Network error: ' + error);
            });
        }

        function showAllMines() {
            $.get('/Home/GetBoardState', function(data) {
                if (data.success) {
                    console.log('Revealing all mines for debugging');
                    
                    // Show all mines on the board
                    data.minePositions.forEach(function(mine) {
                        var cell = $('[data-row="' + mine.row + '"][data-col="' + mine.col + '"]');
                        if (!cell.hasClass('revealed')) {
                            cell.addClass('mine-debug');
                            cell.text('ðŸ’£');
                            cell.css({
                                'background-color': '#ffcccc',
                                'border': '2px solid #ff0000'
                            });
                        }
                    });
                    
                    alert('All ' + data.minePositions.length + ' mines are now visible with pink background and red border.\nClick "New Game" to reset.');
                } else {
                    console.error('Error:', data.error);
                    alert('Error: ' + data.error);
                }
            }).fail(function(xhr, status, error) {
                console.error('AJAX Error:', error);
                alert('Network error: ' + error);
            });
        }
    </script>
}